# Story 1.9: Risk-Driven Portfolio Optimization

## Status
To Do

## Story
**As a** Portfolio Risk Manager,
**I want** to implement VaR/CVaR-based risk budgets and dynamic leverage limits in the Parquet/Arrow/cuDF pipeline,
**so that** the platform can enforce risk constraints during optimization and prevent portfolio concentration beyond acceptable risk thresholds

## Acceptance Criteria
1. VaR/CVaR calculations integrated into the portfolio optimization process
2. Capital allocation respects predefined risk budgets with automatic rebalancing
3. CI tests cover risk scenarios including extreme market conditions

## Tasks / Subtasks

### Task 1: VaR/CVaR Risk Budget Integration (AC: 1)
- [ ] Subtask 1.1: Enhance existing risk metrics for optimization constraints
  - [ ] Extend `/backend/lib/advanced_analytics/risk_metrics.py` with portfolio-level risk budgets
  - [ ] Implement VaR-based position sizing limits per strategy
  - [ ] Add CVaR constraints for tail risk management
  - [ ] Create risk budget monitoring and alerting system
- [ ] Subtask 1.2: Integrate risk constraints into algorithm optimization
  - [ ] Modify genetic algorithm to respect VaR constraints during crossover/mutation
  - [ ] Update particle swarm optimization with risk-aware particle movement
  - [ ] Enhance simulated annealing with risk penalty functions
  - [ ] Add risk constraint validation to all 8 optimization algorithms
- [ ] Subtask 1.3: Implement real-time risk monitoring during optimization
  - [ ] Add portfolio VaR calculation at each optimization iteration
  - [ ] Create risk budget breach detection and mitigation
  - [ ] Implement dynamic rebalancing when risk limits are exceeded
  - [ ] Add risk contribution analysis per strategy in portfolio

### Task 2: Dynamic Leverage Limits Implementation (AC: 2)
- [ ] Subtask 2.1: Create dynamic leverage calculation engine
  - [ ] Implement Kelly Criterion-based leverage sizing using existing win/loss ratios
  - [ ] Add market regime-based leverage adjustments using `Regime_Confidence_%`
  - [ ] Create volatility-adjusted leverage limits using rolling volatility metrics
  - [ ] Implement correlation-based leverage scaling to prevent concentration risk
- [ ] Subtask 2.2: Capital allocation with risk budget respect
  - [ ] Enhance zone optimizer to respect individual zone risk budgets
  - [ ] Implement portfolio-level capital allocation with VaR constraints
  - [ ] Add dynamic position sizing based on strategy-specific risk metrics
  - [ ] Create risk-parity allocation option as fallback when constraints are breached
- [ ] Subtask 2.3: Integration with Parquet/Arrow/cuDF pipeline
  - [ ] Modify cuDF-based calculations to include risk constraint enforcement
  - [ ] Add GPU-accelerated VaR/CVaR calculations to optimization loop
  - [ ] Implement efficient risk metric updates using Arrow memory pools
  - [ ] Create risk-aware portfolio selection using cuDF operations

### Task 3: Risk Scenario Testing Framework (AC: 3)
- [ ] Subtask 3.1: Create comprehensive risk scenario test suite
  - [ ] Implement stress testing with 2008 financial crisis scenarios
  - [ ] Add COVID-19 market crash simulation tests
  - [ ] Create extreme volatility spike scenario testing
  - [ ] Test portfolio behavior during regime transitions
- [ ] Subtask 3.2: Automated CI/CD risk testing integration
  - [ ] Add risk constraint validation to existing test suite in `/backend/tests/`
  - [ ] Create automated VaR/CVaR calculation accuracy tests
  - [ ] Implement portfolio risk budget breach detection tests
  - [ ] Add regression tests for risk-adjusted optimization results
- [ ] Subtask 3.3: Performance impact validation
  - [ ] Measure optimization speed impact of risk constraints
  - [ ] Validate memory usage with risk calculations on 100k+ strategies
  - [ ] Test GPU memory efficiency with enhanced risk metrics
  - [ ] Benchmark risk-constrained vs unconstrained optimization performance

### Task 4: Risk Configuration and Management Interface
- [ ] Subtask 4.1: Risk configuration system implementation
  - [ ] Extend `/config/production_config.ini` with risk budget settings
  - [ ] Add VaR/CVaR confidence levels and lookback periods configuration
  - [ ] Create leverage limit configuration per zone and market regime
  - [ ] Implement risk tolerance profiles (conservative, moderate, aggressive)
- [ ] Subtask 4.2: Risk reporting and monitoring enhancements
  - [ ] Enhance existing output generation engine with risk metrics
  - [ ] Add risk budget utilization charts to visualization suite
  - [ ] Create VaR/CVaR tracking reports over time
  - [ ] Implement risk attribution analysis by strategy and zone
- [ ] Subtask 4.3: Risk alerting and notification system
  - [ ] Create risk budget breach alerting mechanism
  - [ ] Add threshold-based risk warnings to job processor
  - [ ] Implement automatic portfolio rebalancing triggers
  - [ ] Create risk escalation procedures for extreme scenarios

### Task 5: Advanced Risk Management Features
- [ ] Subtask 5.1: Correlation-based risk diversification
  - [ ] Enhance correlation matrix calculations for risk clustering detection
  - [ ] Implement risk parity allocation considering correlation structure
  - [ ] Add dynamic correlation monitoring during market stress
  - [ ] Create correlation-adjusted VaR calculations
- [ ] Subtask 5.2: Market regime risk adaptation
  - [ ] Integrate market regime detection with risk budget adjustments
  - [ ] Implement regime-specific VaR/CVaR calculations
  - [ ] Add dynamic risk tolerance based on regime confidence
  - [ ] Create regime transition risk management protocols
- [ ] Subtask 5.3: Multi-timeframe risk analysis
  - [ ] Implement intraday VaR calculations using zone data
  - [ ] Add daily, weekly, and monthly risk budget tracking
  - [ ] Create rolling risk metrics with different lookback periods
  - [ ] Implement forward-looking risk projections

## Dev Notes

### Previous Story Context
This story builds upon the existing risk analytics infrastructure and integrates it into the active optimization process. Key dependencies:

**From Existing Risk Infrastructure**: Advanced risk metrics calculator with VaR/CVaR already implemented
**From Parquet/Arrow/cuDF Story**: Modern data pipeline for efficient GPU-accelerated calculations
**From Stories 1.1-1.4**: Complete optimization workflow with 8 algorithms ready for risk constraint integration

### Data Models
**Enhanced Risk Configuration Schema**:
```ini
[RISK_MANAGEMENT]
# VaR/CVaR Settings
var_confidence_levels = 95,99,99.5
cvar_confidence_levels = 95,99
lookback_periods = 20,60,252
risk_budget_percentage = 15.0

# Leverage Limits
max_portfolio_leverage = 2.0
regime_leverage_multipliers = {"bull": 1.2, "bear": 0.8, "transition": 0.9}
volatility_leverage_scaling = true

# Risk Budget Allocation
zone_risk_budgets = {"0-100": 2.5, "101-200": 2.5, ...}
strategy_max_risk_contribution = 5.0
correlation_concentration_limit = 0.7
```

**Risk-Constrained Optimization Parameters**:
```python
{
    'var_constraint': 0.025,  # Maximum 2.5% daily VaR
    'cvar_constraint': 0.035,  # Maximum 3.5% daily CVaR
    'leverage_limit': 2.0,     # Maximum 2x leverage
    'max_strategy_weight': 0.1, # Maximum 10% per strategy
    'risk_budget_total': 0.15,  # Total portfolio risk budget 15%
    'correlation_limit': 0.7,   # Maximum correlation exposure
}
```

### API Specifications
**Risk-Constrained Optimization Interface**:
```python
# Enhanced optimization with risk constraints
def optimize_with_risk_constraints(
    data: cudf.DataFrame,
    portfolio_size: int,
    risk_constraints: RiskConstraints,
    algorithm: str = 'genetic_algorithm'
) -> OptimizationResult

# VaR/CVaR calculation for optimization
def calculate_portfolio_risk_metrics(
    portfolio: List[int],
    weights: np.ndarray,
    returns_data: cudf.DataFrame,
    confidence_levels: List[float] = [95, 99]
) -> Dict[str, float]

# Dynamic leverage calculation
def calculate_optimal_leverage(
    strategy_metrics: Dict[str, float],
    market_regime: str,
    current_volatility: float,
    correlation_matrix: np.ndarray
) -> float
```

### Component Specifications
**Risk-Constrained Optimization Engine**:
- Location: `/backend/lib/risk_optimization/risk_constrained_optimizer.py`
- Integration: Extends existing algorithm interfaces with risk constraint validation
- Performance: GPU-accelerated risk calculations using cuDF operations
- Monitoring: Real-time risk metric tracking during optimization iterations

**Risk Budget Manager**:
- Location: `/backend/lib/risk_management/risk_budget_manager.py`
- Function: Monitors and enforces risk budget allocations across zones and strategies
- Alerting: Automatic rebalancing triggers when budgets are exceeded
- Reporting: Risk utilization tracking and attribution analysis

**Dynamic Leverage Controller**:
- Location: `/backend/lib/risk_management/leverage_controller.py`
- Features: Kelly Criterion sizing, regime-based adjustments, volatility scaling
- Integration: Works with existing market regime detection and confidence scoring
- Safety: Maximum leverage caps and risk-based position sizing limits

### File Locations
**New Components**:
- Risk optimization engine: `/backend/lib/risk_optimization/risk_constrained_optimizer.py`
- Risk budget manager: `/backend/lib/risk_management/risk_budget_manager.py`
- Leverage controller: `/backend/lib/risk_management/leverage_controller.py`
- Risk configuration: `/config/risk_management_config.ini`

**Enhanced Components**:
- Main workflow: `/backend/parquet_cudf_workflow.py` (add risk constraint integration)
- Algorithm factory: `/backend/algorithms/algorithm_factory.py` (risk-aware algorithm selection)
- Risk metrics: `/backend/lib/advanced_analytics/risk_metrics.py` (optimization integration)
- Output engine: `/backend/output_generation_engine.py` (enhanced risk reporting)

### Testing Requirements
**Risk Scenario Validation**:
- Execute optimization with extreme market scenarios (2008 crisis, COVID crash)
- Validate risk constraint enforcement across all 8 algorithms
- Test portfolio rebalancing during risk budget breaches
- Verify VaR/CVaR accuracy against known benchmarks

**Performance Testing**:
- Measure optimization speed impact of risk constraints (target: <20% slowdown)
- Test memory efficiency with enhanced risk calculations
- Validate GPU utilization with risk-constrained optimization
- Benchmark against unconstrained optimization for accuracy comparison

**Integration Testing**:
- End-to-end workflow with risk constraints enabled
- Cross-validation with existing risk analytics results
- Job queue processor integration with risk alerting
- Configuration management for different risk tolerance profiles

### Technical Constraints
**Risk Calculation Requirements**:
- Real-time VaR/CVaR calculation during optimization iterations
- GPU memory efficiency for large correlation matrices (25,544×25,544)
- Sub-second risk metric updates for interactive optimization
- Numerical stability for extreme market scenarios

**Optimization Constraints**:
- Maintain existing optimization accuracy within ±0.001% tolerance
- Preserve algorithm convergence properties with risk constraints
- Support all existing CSV input formats with risk enhancements
- Backward compatibility with risk-unconstrained optimization

**Performance Requirements**:
- Risk-constrained optimization within 150% of unconstrained runtime
- Memory overhead <20% for risk calculation components
- GPU memory efficiency for 100k+ strategy optimization
- Real-time risk monitoring with <100ms latency

### Enhanced Risk Features Implementation
**VaR-Constrained Portfolio Optimization**:
```python
def optimize_with_var_constraint(population, var_limit=0.025):
    """Ensure portfolio VaR stays within specified limit"""
    for individual in population:
        portfolio_var = calculate_portfolio_var(individual)
        if portfolio_var > var_limit:
            # Reduce position sizes proportionally
            scale_factor = var_limit / portfolio_var * 0.95  # 5% buffer
            individual.weights *= scale_factor
    return population
```

**Dynamic Leverage Sizing**:
```python
def calculate_kelly_leverage(win_rate, avg_win, avg_loss, max_leverage=2.0):
    """Calculate optimal leverage using Kelly Criterion with safety limits"""
    kelly_fraction = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
    optimal_leverage = max(0.1, min(kelly_fraction, max_leverage))
    return optimal_leverage
```

**Risk Budget Enforcement**:
```python
def enforce_risk_budgets(portfolio, individual_budgets, total_budget):
    """Enforce individual and total risk budget constraints"""
    risk_contributions = calculate_risk_contributions(portfolio)
    
    # Check individual strategy limits
    for i, contribution in enumerate(risk_contributions):
        if contribution > individual_budgets.get(i, 0.05):  # 5% default
            portfolio.weights[i] *= individual_budgets[i] / contribution
    
    # Check total risk budget
    total_risk = sum(risk_contributions)
    if total_risk > total_budget:
        portfolio.weights *= total_budget / total_risk
    
    return portfolio
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-02 | 1.0 | Initial epic story creation for risk-driven portfolio optimization | PM Agent |

## Dev Agent Record

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be updated during implementation]

### Completion Notes List
[To be updated during implementation]

### File List
[To be updated during implementation]

## QA Results

### QA Review Summary
[To be completed by QA Agent after implementation]

### Acceptance Criteria Verification
[To be completed by QA Agent]

### Test Results
[To be completed by QA Agent]

### Code Quality Assessment
[To be completed by QA Agent]

### Issues Found
[To be completed by QA Agent]

### Compliance Check
[To be completed by QA Agent]

### Final QA Verdict
[To be completed by QA Agent]